package com.vivi.scarm.test

import cats.effect.IO
import doobie._
import doobie.implicits._
import doobie.util.transactor.Transactor
import org.scalatest.FunSuite

import com.vivi.scarm._

import TestObjects._

case class SimpleId(id: Int) extends AnyVal
case class SimpleEntity(id: SimpleId, x: Int, name: String)
    extends Entity[SimpleId]

case class IntId(id: Int)
case class StringId(string: Int)

case class IntEntity(id: Int, name: String, intval: Option[String])
    extends Entity[Int]

case class StringEntity(id: StringId, name: String, strval: Option[String], intval: Option[Int])
    extends Entity[StringId]

class DSLTest extends FunSuite {
  /*
  val jdbcDriver = "org.hsqldb.jdbc.JDBCDriver"
  val jdbcUrl = "jdbc:hsqldb:file:testdb"
  val jdbcUsername = "SA"
  val jdbcPassword = ""
   */
  
  val jdbcDriver = "org.postgresql.Driver"
  val jdbcUrl = "jdbc:postgresql:scarm"
  val jdbcUsername = "scarm"
  val jdbcPassword = "scarm"


  implicit val xa: Transactor[IO] = Transactor.fromDriverManager[IO](
    jdbcDriver, jdbcUrl, jdbcUsername, jdbcPassword
  )
  /*
  implicit val xa: Transactor[IO] = Transactor.fromDriverManager[IO](
    ", " , "scarm" , "scarm"
  )
   */

  test("after inserting an entity, it can be selected by primary key") {
    val table = Table[SimpleId,SimpleEntity]("simple_entity")
    table.create().transact(xa).unsafeRunSync()
    table.drop.transact(xa).unsafeRunSync()
  }

  test("after inserting multiple entities, they can each be selected by primary key") {
    val table = Table[SimpleId,SimpleEntity]("simple_entity")
  }

  test("after deleting an entity, the entity cannot be found by primary key") (pending)

  test("after updating an entity, selecting the entity by primary key returns the new entity") (pending)

  test("after dropping a table, the table cannot be used for inserts or selects") (pending)

  test("SQL on a table with Date fields") (pending)

  test("SQL on a table with a primitive Primary Key") (pending)

  test("SQL on a table with a String Primary Key") (pending)

  test("SQL on a table with a compound Primary Key") (pending)

  test("SQL on a table with a Dates in Primary Key") (pending)

  test("SQL on a table with nested objects") (pending)

  test("SQL on a table with nullable String fields") (pending)

  test("SQL on a table with nullable AnyVal fields") (pending)

  test("SQL on a table with nullable nested object field") (pending)

  test("SQL on a table with autogenerated primary key") (pending)

  test("SQL on a table with explicit field names") (pending)

  test("SQL on a table with explicit key names") (pending)

  test("SQL on a table with field overrides") (pending)

  test("SQL on a table with sql type overrides") (pending)

  test("Query by Index") (pending)

  test("Query by Index with no results") (pending)

  test("Query by Unique Index") (pending)

  test("Query by Unique Index with no results") (pending)

  test("Query by Foreign Key") (pending)

  test("Query a View") (pending)

  test("A mandatory foreign key is a constraint")(pending)

  test("An optional foreign key is a constraint")(pending)

  test("An optional foreign key is optional")(pending)

  test("Query a Many to One Join on Mandatory Foreign Key") (pending)

  test("Many to One Join on Mandatory Foreign Key is Inner") (pending)

  test("Query a Many to One Join on Optional Foreign Key") (pending)

  test("Many to One Join on Optional Foreign Key is Outer") (pending)

  test("Query a One to Many Join") (pending)

  test("One to Many Join is Outer") (pending)

  test("Query three queries joined by many to one") (pending)

  test("Query three queries joined by one to many") (pending)

  test("Query three queries joined by one to many and many to one") (pending)

  test("Query three queries joined by many to one and one to many") (pending)

  test("Query with a Nested Join") (pending)
}
